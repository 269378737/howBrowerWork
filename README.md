浏览器的工作原理：新式网络浏览器幕后揭秘
===================================

## 序言

这是一篇全面介绍Webkit和Gecko内部操作的入门文章，是以色列开发人员塔利·加希尔大量研究的成果。在过去的几年中，她查阅了所有公开发布的关于浏览器内部机制的数据（详见[资料](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Resources)），并花了很多时间来研读网络浏览器的源代码。她写道：

> 在IE占据90%市场份额的年代，我们除了把浏览器当成一个“黑箱”，什么也做不了。但是现在，开放源代码的浏览器拥有了过半的市场份额，因此，是时候来揭开神秘的面纱，一谈网络浏览器的内幕了。额，里面只有数以百万计的C++代码...

塔利在她的[网站](http://taligarsiel.com/)上公布了自己的研究成果，但是我们觉得它值得让更多的人来了解，所以我们在此重新整理并公布。

作为一名网络开发人员，学习浏览器的内部功罪原理将有助于您做出更明智的决策，并理解那些最佳开发时间的个中缘由。尽管这是一篇相当长的文档，但是我们建议您花些事件来仔细阅读；读完之后，您肯定会觉得所费不虚。

## 简洁

网络浏览器很可能是使用最广的软件。在这篇入门文章中，我将会介绍他们的幕后工作原理。我们会了解到，从您在地址栏输入google.com直到您在浏览器屏幕上看到Google首页的整个过程中都发生了什么。

## 我们要讨论的浏览器

目前使用的主流浏览器有五个：Internet Explorer、 Firefox、 Safari、 Chrome浏览器和Opera。本文中以开放源代码浏览器为例，目前Firefox、 Chrome浏览器和Safari（部分开源）。根据[StatCounter浏览器统计数据](http://gs.statcounter.com/)，目前Firefox、 Safari和Chrome浏览器的总市场占有率将近60%。由此可见，如今开放源代码浏览器在浏览器市场中战绝非常监事的部分。

## 浏览器的主要功能

浏览器的主要功能就是向服务器发送请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指HTML文档，也可以是PDF、图片或其他的类型。资源的位置由用户的URL（统一资源标识符）指定。

浏览器解释并显示HTML文档的方式是在HTML和CSS规范中指定的。这些规范由网络标准化组织`W3C`（万维网联盟）进行维护。

多年以来，各个浏览器都没有完全遵循这些规范，同时还在开发自己独有的扩展程序，这给昂罗开发人员带来了严重的兼容性问题。如今，大多数浏览器都算是或多或少地遵从规范。

浏览器的用户界面有很多彼此相同的元素，其中包括：

*	用来输入URL的地址栏
*	前进和后退按钮
*	数钱设置选项
*	用于刷新和停止加载当前文档的刷新和停止按钮
*	用于返回主页的主页按钮

奇怪的是，浏览的用户界面并没有任何真实规范，这是多年的最佳实践自然发展以及批次之间相互模仿的结果。HTML5也没有定义浏览器必须具备的用户界面元素，但列出了一些通用的元素，例如地址栏，状态栏和工具栏等。当然，各个浏览器也可以有自己独特的功能，比如Firefox的下载管理器。

## 浏览器的高层结构

浏览器的主要组件为：

1.	用户界面-包括地址栏、前进、后退按钮，数钱菜单等。除了浏览器主窗口显示您请求的页面外，其他显示的各个部分都属于用户界面。
2.	浏览器殷勤-用户界面和呈现引擎之间传送命令。
3.	呈现引擎-负责显示请求的内容。如果请求的内容是HTML，它就负责解析HTML和CSS内容，并将解析后的内容显示在屏幕上。
4.	网络-用户网络调用，比如http请求。其接口与平台无关，并为所有平台提供底层实现。
5.	用户界面后端-用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台的童工接口，而在底层使用操作系统的用户界面方法。
6.	javascript解释器-用于解析和执行javascript代码
7.	数据存储-这是持久层。浏览器需要在硬盘上保存各种数据，例如cookie。

新的HTML规范（HTML5）定义了“网络数据库”，这是一个完整的浏览器内部数据库。

图为----浏览器的主要部件

![](/img/1.png)

值得注意的是，和大多数浏览器不同，Chrome浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。

## 呈现引擎

呈现引擎的作用：当然是“呈现”，也就是在浏览器的屏幕上显示请求的内容。

默认情况下，呈现引擎可显示HTML和XML文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用PDF查看器就能显示PSF文档。但是在本章中，我们将集中介绍其主要用途：显示使用CSS格式化的HTML内容和图片。

## 呈现引擎

本文所讨论的浏览器（Firefox、Chrome浏览器和Safari）是基于两种呈现引擎构建的。Firefox使用的Gecko，这是Mozilla公司“自制”的呈现引擎。而Safari和Chrome浏览器使用的都是webkit。

Webkit是一种开放源代码呈现引擎，起初用于Linux品台，随后由Apple公司进行修改，从而支持苹果机和Windows。有关详情，请参阅[webkit.org](https://webkit.org/)

## 主流程

呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在8000个块以内。

然后进行如下所示的基本流程：

![](/img/2.png)

呈现引擎将开始解析HTML文档，并将各个标记逐个穿化成“内容树”上的DOM节点。同事也会解析外部CSS文件以及样式元素中的样式数据。HTML中这些带有视觉指令的样式信息将用于创建另一个树结构：`呈现树`。

呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。

呈现树构建完毕之后，进入`布局`处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是`绘制`-呈现引擎会遍历呈现树，有用户界面后端层将每个节点绘制出来。

需要着重支出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个HTML文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接受和处理来自网络的奇遇内容的同事，呈现引擎会将部分内容解析并显示出来。

#### 主要流程

![](/img/3.png)
Webkit主流程

![](/img/4.jpg)
Mozilla的Decko呈现引擎主流程

从图3和图4可以看出，虽然webkit和decko使用的术语略有不同，但整体流程是基本相同。

Gecko将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。webkit使用的术语是“呈现树”，它由“呈现对象”组成。对于元素的防治，webkit使用的术语是“布局”，而gecko称之为“重排”。对于连接DOM节点和可视化信息从创建呈现书的过程，webkit使用的术语是“附加”。有一个细微的非语义差别，就是Gecko在HTML与DOM树之间还有一个称为“内容槽”的层，用于生成DOM元素。我们会逐一论述流程中的每一部分：

## 解析-综述

解析是呈现引擎中非常重要的一个环节，因此我们要更深入地讲解。首先，来介绍一下解析。

解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树。

示例-解析`2 + 3 - 1`这个表达式，会返回下面的树：

![](img/5.png)
数学表达式树节点

## 语法

解析是以文档所遵循的语法规则（编写文档所有的语言或格式）为基础。所有可以解析的格式都必须对应确定的语法（由词汇和语法规则构成）。这称为[与上下文的语法](https://en.wikipedia.org/wiki/Context-free_grammar)。人类语言并不属于这样的语言，因此无法用常规的解析技术进行解析。

## 解析器和语法分析器的组合

解析的过程可以分成两个子过程：语法分析和词法分析

词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，级构成内容的单位。在人类语言中，它相当于语言字典中的单词。

语法分析是应用语言的语法规则的过程。

解析器通常将解析工作分给一下两个组件：`词法分析器`（有时也称为标记生成器），负责将输入内容分解成一个个有效标记；而`解析器`负责根据语言的语法规则分析文档的结构，从而构建解析树。词法分析器知道如何将无关的字符（比如空格和换行符）分离出来。

![](img/6.png)
图：从源文档到解析树

解析是一个迭代的过程。通常，解析器回想词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发生了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。

如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，知道找到可与所有内部存储匹配的标记匹配规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。

## 翻译

很多时候，解析树还不是最终产品。解析通常是在翻译过程中使用，而翻译是指将输入文档转换成另一种格式。变异就是这样一个例子。编译器可将源代码变异成机器代码，具体过程是首先将源代码解析成解析树，然后将解析树翻译成机器代码文档。

![](img/7.png)

## 解析示例

在图5中，我们通过一个数学表达式建立了解析树。现在，让我们试着定义一个简单的数学语言，用来演示解析的过程。

词汇：我们用的语言可包含整数、加号和减号。

语法：

1.	构成语言的语法单位是表达式，项和运算符
2.	我们用的语言可以包含任意数量的表达式
3.	表达式的定义是：一个“项”接一个“运算符”，然后再接一个“项”
4.	运算符是加号或减号
5.	项是一个整数或一个表达式

让我们分析一下`2 + 3 -1`。

匹配语法规则的第一个子串`2`，根据第五条无法规则，这是一个项。匹配语法规则的第二个子串是`2 + 3`，而根据第三条规则（一个项接一个运算符，然后接一个项），这是一个表达式。下一个匹配已经到了输入结束。`2 + 3 -1`是一个表达式，因为我们已经知道 `2　＋　3`是一个项，这样就符合“一个项接一个运算符”，然后再接一个项的规则，`2 + +`不与任何规则匹配，因此是无效的输入。

## 词汇和语法的正式定义

词汇通常用[正则表达式](http://www.regular-expressions.info/)表示。

例如，我们的示例语言可以定义如下：

```

INTEGER : 0|[1-9][0-9]*

PLUS : +

MINUS: -

```

正如您所看到的，这里用正则表达式给出了整数的定义。

语法通常使用一种称为[BNF](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form)的格式来定义。我们的示例语言可以定义如下：

```

expression := term operation term

operation := PLUS | MINUS

term := INTEGER | expression

```

之前我们说过，如果语言的语法是与上下文无关的语法，就可以由常规解析器进行解析。与上下文无关的语法的直观定义就是可以完全用BNF格式表达的语法。有关正式定义，请参阅[关于与上下文无关的语法的危机百科文章](https://en.wikipedia.org/wiki/Context-free_grammar)

## 解析器类型

有两种基本类型的解析器：自上而下解析器和自下而上解析器。直观地来说，自上而下的解析器从语法的高层结构触发，尝试从中找到匹配的结构。而自下而上的解析器从低层规则出发，将输入内容逐步转化为语法规则，直至满足高层规则。

让我们来看看这两种解析器如何解析我们的示例：

自上而下的解析器会从高层的规则开始：首先将`2 + 3`表示为一个表达式，然后将`2 + 3 - 1`表示为一个表达式（表示表达式的过程涉及到匹配其他规则，但是起点是最高级的规则）。

自下而上的解析器将扫描输入的内容，找到匹配的规则后，将匹配的输入内容替换成规则。如此继续替换，直到输入内容的结尾。部分匹配的表达式保存在解析器的堆栈中。

<table>
	<tr>
		<td>堆栈</td>
		<td>输入</td>
	</tr>
	<tr>
		<td></td>
		<td>2 + 3 -1</td>
	</tr>
	<tr>
		<td>项</td>
		<td>+ 3 - 1</td>
	</tr>
	<tr>
		<td>项运算</td>
		<td>3 - 1</td>
	</tr>
	<tr>
		<td>表达式</td>
		<td>- 1</td>
	</tr>
	<tr>
		<td>表达式运算符</td>
		<td>1</td>
	</tr>
	<tr>
		<td>表达式</td>
		<td></td>
	</tr>
</table>

这种紫霞而上的解析器称为移位归约解析器，因为输入在向右位移（设想有一个指针从输入内容的开头移动到结尾），并且逐渐归约到语法规则上。

## 自动生成解析器

有一些工具可以帮助仅生成解析器，他们称为解析器生成器。您只要想其提供所有语言的语法（词汇和语法规则），它就会生成相应的解析器。创建解析器需要对解析有深刻理解，而人工创建并优化解析器并不是一件容易的事情，所有解析器生成器是非常实用的。

Webkit使用了两种非常有名的解析器生成器：用于创建词法分析器的Flex以及用于创建解析器的Bison（仅可能遇到Lex和Yacc这样的别名）。Flex的输入是包含标记的正则表达式定义的文件。Bison的输入采用BNF格式的语言语法规则。

## HTML解析器

HTML解析器的任务是将HTML标记解析成解析树。

## HTML语法定义

HTML的词汇和语法在W3C组织创建的规范中进行了定义。当前版本是HTML4，HTML5正在处理过程中。

## 非与上下文无关的语法

正如我们在解析过程的介绍中已经了解到的，语法可以用BNF等格式进行正式定义。

很遗憾，所有的常规解析器都不适用与HTML（我并不是开玩笑，他们可以用于解析CSS和JavaScript）。HTML并不能很容易地用解析器所需的与上下文无关的语法来定义。

有一种可以定义HTML的正式格式DTD（Document Type Definition，文档类型定义），但它不是与上下文无关的语法。

这初看起来很奇怪：HTML和XML非常相似。有很多XML解析器可以使用。HTML存在一个XML变体（XHTML），那么有什么大的区别呢？

区别在于HTML的处理更为“宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些启示或者结束标记等等。和XML严格的语法不同，HTML整体来看是一种“软性”的语法。

显然，这种看上去细微的差别实际上却带来了巨大的影响。一方面，这是HTML和此流行的原因：它能包容您的错误，简化网路开发。另一方面，这使得它很难编写正式的语法。概括地说，HTML无法很容易地通过常规解析器解析（因为它的语法不是与上下文无关的语法），也无法通过XML解析器来解析。

## HTML DTD

HTML的定义采用了DTD格式。此格式可用于定义SGML族的语言。它包括所有允许使用的元素及其属性和层次结构的定义。如上文所述，HTML DTD无法构成与上下文无关的语法。

DTD存在一些变体。严格模式完全遵循HTML规范，而其他魔石可支持以前的浏览器使用的标记。这样做的目的是确保向下兼容一些早期版本的内容。最新的严格模式DTD可以这里找到：[https://www.w3.org/TR/html4/strict.dtd](https://www.w3.org/TR/html4/strict.dtd)

## DOM

解析器的输出“解析树”是由DOM的元素和属性节点构成的树结构。DOM是文档对象模型（Document Object Model）的缩写。它是HTML文档的对象表示，同事也是外部（例如JavaScriipt）与HTML元素之间的接口。

解析树的根节点是“Document”对象。

DOM与标记之间几乎是一一对应的关系。比如下面这段标记：

```html

<html>
	<body>
		<p>
			Hello World
		</p>
		<div> <img src="example.png"> </div>
	</body>
</html>

```

可翻译成如下的DOM树：

![](img/8.png)

和HTML一样，DOM也是由W3C阻止指定的。请参见[https://www.w3.org/DOM/DOMTR](https://www.w3.org/DOM/DOMTR)。这是关于文档操作的通用规范。其中一个特定模块描述了针对HTML的元素。HTML的定义可以在这里找到：[https://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html](https://www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html)

我所说的树包含DOMN节点，指的是树是由实现了某个DOM接口的元素构成的。浏览器在具体的实现中会有一些供内部使用的其他属性。

## 解析算法

我们在之前章节已经说过，HTML无法用常规的自上而下或自下而上的解析器进行解析。

原因在于：

1.	 语言的宽容本质
2.	 浏览器历来对一些常见的无效HTML用法采取包容态度
3.	 解析过程需要不断地反复。原内容在解析过程中通常不会改变，但是在HTML中，脚本标记如果包含doucment.write，就会添加额外的标记，这样结系过程实际上就更改了输入内容。

由于不能使用常规的杰西技术，浏览器就创建了自定义的解析器来解析HTML。HTML5规范详细地描述了解析算法。此算法由两个阶段组成：标记化和树构建。

标记化是词法分析过程，将输入内容解析成多个标记。HTML标记包括其实标记和结束标记、属性名和属性值。

标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记如此反复直到输入的结束。

![](img/9.png)图：HTML解析过程（摘自HTML5规范）

## 标记化算法

该算法的输出结果是HTML标记。该算法使用状态机来表示。每一个状态接受来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态。当前的标记化状态和树结构状态会影响进入下一状态的决定。这意味着，计时接受的字符相同，对于下一个正确的状态也会影响进入下一状态的决定。这意味着，计时接受的字符相同，对于下一个正确的状态也会产生不同的结果，具体取决于当前的状态。该算法相当复杂，无法再此详述，所以我们通过一个简单的示例来帮助大家理解其原理。

基本示例 - 将下面的HTML化码标记化：

```html

	<html>
		<body>
			Hello World	
		</body>
	</html>

```

书构建阶段的输入是一个来自标记化阶段的标记序列。第一个模式是“initial mode”。接收HTML标记后转为“before html”模式，并在这个模式下重新处理此标记。这样会创建一个HTMLHtmlElement元素，并将其附加到Documnet根对象上。

然后状态将改为“before head”。此时我们接受“body”标记。计时我们的实例中没有“head”标记，系统也会隐式创建一个HTMLHeadElement，并将其添加到树种。

现在我们进入了“in head”模式，然后转入“after head”模式。系统对body标记进行重新处理，创建并插入HTMLBodyElement，同时模式转变成“in body”。

现在，接收由“Hello World”字符串生成的一系列字符标记。接收第一个字符时会创建并插入“Text”节点，而其他字符也将附加到该节点。

接收body结束标记会触发“after body”模式。现在我们将接收HTML结束标记，然后进入“after after body”模式。接收到文件结束标记后，解析过程就此结束。

![](img/10.gif) 图：示例HTML的树构建

## 解析结束后的操作

在此阶段，浏览器会将文档标注为交互状态，并开始解析那些处于“deferred”模式的脚本，也就是那些应在文档解析完成后才执行的脚本。然后，文档状态设置为“完成”，一个“加载”时间将随之触发。

您可以在[HTML5规范中查看标记化和树构件的完整算法](https://www.w3.org/TR/html5/syntax.html#html-parser)

## 浏览器的容错机制

您在浏览HTML网页时从来不会看到“语法无效”的错误。这是因为浏览器会纠正任何无效内容，然后继续工作。

一下的HTML代码为例：

```html

	<html>
		<mytag></mytag>
		<div>
		<p>
		</div>
			Really lousy HTML
		</p>
	</html>

```

在这里，我们已经违反了很多语法规则（“mytag”不是准确的标记，“p”和“div”元素之间的嵌套有误等等），但是浏览器仍然会正确地显示这些内容。并且毫无怨言。因此有大量的解析器代码会纠正HTML网页作者的错误。

不同浏览器的错误处理机制相当一致，但令人称奇的是，这种机制并不是HTML当前规范的一部分。和数钱管理以及前进、后退按钮一样，它也是浏览器多年发展中的产物。很多网站普遍存在着一些已知的无效HTML结构，每一种浏览器都会尝试通过和其他浏览器一样的方式来修复这些无效结构。

HTML5规范定义了一部分这样的要求。Webkit在HTML解析器类的开头注释中对此作了很好的概括。

> 解析器对标记化输入内容进行解析，以构建文档树。如果文档的格式正确，就直接进行解析。
>
>遗憾的是，我们不得不处理很多错误格式的HTML文档，所以解析器必须具备一定的容错性。
>我们至少能够处理一下错误情况：
> * 明显不能在某些外部标记中添加的元素。在此情况下，我们应该关闭所有标记，知道出现禁止天机的元素，然后再加入该元素。
> * 我们不能直接添加的元素。这很可能是网页作者忘记添加了其中的一些标记（或者其中的标记是可选的）。这些标签可能包括：HTML HEAD BODY TBODY TR TD LI。
> * 像inline元素内添加block元素。关闭所有inline元素，知道出现下一个高级的block元素
> * 如果这样仍然无效，可关闭所有元素，知道可以添加元素为止，或者忽略该标记。

让我们看一下Webkit容错的示例：

## 使用了</br>而不是<br>

有些网站使用了</br>而不是<br>。为了与IE和Firefox兼容，Webkit将其与<br>做同样的处理。

代码如下：

```

	if (t->isCloseTag(brTag) && m_document->inCompatMode()) {
		reportError(MalformedBRError);
		t->beginTag = true;
	}

```

请注意，错误处理是在内部进行的，用户并不会看到这个过程。

## 离散表格

离散表格是指位于其他表格内容中，但又不在任何一个单元格内的表格。

比如以下的示例：

```html

	<table>
	    <table>
	        <tr><td>inner table</td></tr>
	    </table>
	    <tr><td>outer table</td></tr>
	</table>

```

Webkit会将其层次结构更改为两个同级表格

```html

	<table>
	    <tr><td>outer table</td></tr>
	</table>
	<table>
	    <tr><td>inner table</td></tr>
	</table>

```

代码如下：

```

	if (m_inStrayTableContent && localName == tableTag)
        popBlock(tableTag);

```

Webkit使用了一个堆栈来保存当前的元素内容，它会从外部表格的堆栈中弹出内部表格。现在，这两个表格就变成了同级关系。

## 嵌套的表单元素

如果用户在一个表单元素中放入了另一个表单，那么第二个表单将会被忽略。

代码如下：

```

	if (!m_currentFormElement) {
        m_currentFormElement = new HTMLFormElement(formTag,m_document);
	}

```

## 过于复杂的标记层次结构

代码的注释已经说的很清楚了。

> 示例网站www.liceo.edu.mx嵌套了约1500个标记，全都来自一堆<b>标记我们只允许最多20层同类型标记的嵌套，如果在嵌套更多，就会全部忽略。

```

		bool HTMLParser::allowNestedRedundantTag(const AtomicString& tagName)
		{
		
		unsigned i = 0;
		for (HTMLStackElem* curr = m_blockStack;i < cMaxRedundantTagDepth && curr && curr->tagName == tagName;curr = curr->next, i++) { }
		return i != cMaxRedundantTagDepth;
		}

```

## 放错位置的html或者body结束标记

同样，代码的注释已经说得很清楚了。

> 支持格式非常糟糕的 HTML 代码。我们从不关闭 body 标记，因为一些愚蠢的网页会在实际文档结束之前就关闭。我们通过调用 end() 来执行关闭操作。

```

	if (t->tagName == htmlTag || t->tagName == bodyTag )
        return;

```

所以网页作者需要注意，除非您想作为反面教材出现在Webkit容错代码段的示例中，否则还请编写正确格式的HTML代码。

## CSS解析













[https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#1_1](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#1_1)












## 未完待续...